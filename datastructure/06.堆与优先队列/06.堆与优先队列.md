* 二叉堆 heap : 用完全二叉树结构来维护的一个数组

* 大顶堆(升序、最小的k个值)：每个结点的值都大于或者等于其子树中每个结点的值

* 小顶堆(降序、最大的k个值):  每个结点的值都大于或者等于其子树中每个结点的值

* 大顶堆的构建过程

  * 从最后一个非叶子结点开始从下往上构建，比较当前结点和其左/右子结点的值，如果当前结点值小于其子结点的值则交换两结点的值，检查子树是否满足最大堆的性质

    * 最后一个非叶子结点

      * 堆从0开始索引: i = n / 2 - 1

        ```shell
        # 最后一个叶子结点是左结点
        n - 1 = 2 * i + 1
        i = n / 2 - 1
        # 最后一个叶子结点是右结点
        n - 1 = 2 * i + 2
        i = n / 2 - 3 / 2 = n / 2 - 1
        ```

    * 父/子结点：堆从1开始索引

      * 左子结点 i * 2
      * 右子结点 i * 2 + 1
      * 父结点 i / 2

* 堆排序(降序)：先将无序数组构建成大顶堆，再将根结点下沉，将剩余n-1个元素重新构建成大顶堆，反复直至排序完成。

* 时间复杂度 O(n*logn)

* 优先队列：每一次入队都是堆的插入操作，每一次出队都是堆的删除操作

* 堆的插入操作(结点上浮 swim)：新堆化heapify、从下往上与父结点对比交换
  
  * 时间复杂度 O(n)
  
* 堆的删除堆顶元素操作(结点下沉 sink)
  
  * 时间复杂度 O(n)
  
* 堆的应用

  * topK

    * 静态数据集合
      * 维护一个大小为K的小顶堆，遍历数组O(n)，从数组中取出元素与堆顶元素比较，如果比堆顶元素大，将堆顶元素删除，将新元素插入堆中进行堆化O(logK)
      * 最坏时间复杂度 O(n * logK)
      * [215. 数组中第K个最大元素](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/215.数组中第K个最大元素.cpp)
    * 动态数据集合
      * 维护一个K大小的小顶堆，每次有新数据加入到集合时与堆顶元素进行比较，如果比堆顶元素大，将堆顶元素删除，将新元素插入堆中进行堆化O(logK)。

  * 流里面的中位数（或者求其他百分位的数据，调整两个堆中的元素数量）

    * 静态数据 ： 排序求中位数
    * 动态数据
      * 维护一个大顶堆、一个小顶堆。
        * 大顶堆维护前半部分数据（小）
        * 小顶堆维护后半部分数据（大）
      * 如果n是偶数，大顶堆的堆顶元素就是中位数
      * 如果n是奇数，大顶堆中维护n/2+1个元素，情况类似。
      * 如果新加入的元素小于等于大顶堆的堆顶元素，将其加入大顶堆，否则加入小顶堆
      * 加入新元素后调整两个堆的元素数量，重新堆化满足上面约定，
      * 插入数据 O(logn), 查询O(1)

  * 根据优先级处理网络请求

  * 实现多路有序归并

    * 合并有序小文件

      * 100个小文件，每个文件100MB，每个文件中存储有序字符串，将100个文件合并成一个有序的大文件

        ```cpp
        buildHead(strHead);  // 每个文件取一个最小字符串构建小顶堆
        vector<str> res;
        while (每个文件不为空) {
        res.push_back(strHead.top());  // 取栈顶元素放入大文件中
        strHead.top();  // 并删除栈顶元素
        strHead.push(str)  // 从删除栈顶str所处的小文件中取出下一个字符串放入堆中
        // 循环直至小文件都为空
        ```

  * 高性能定时器

    * 按照任务的执行时间将任务存储在优先数列（小顶堆）中，队首是最先执行的任务。
    * 时间间隔 T = 队首时间 - 当前时间，T秒之后，执行队首任务，重新取堆首时间计算T，将T设定为下一个任务需要等待的时间

  * 从包含10亿个搜索关键词的日志文件中，快速获取Top10最热门的搜索关键词（单机，内存1G）
    * 1.将10亿条搜索关键词通过哈希算法分片到10个文件中
      * 遍历关键词，通过一个哈希算法对其求哈希值，然后同10取模，得到这个关键词被分到的文件编号
    * 2.每个文件1亿个关键词，利用散列表和堆，求出top10
      * 建立大小10的小顶堆，遍历散列表，将每个关键词的出现次数与堆顶元素比较，如果多，则替换后重新堆化
    * 3.将10个top10放在一起，取top10
  * 有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？
    * 1 每篇新闻摘要计算一个哈希值，建立摘要与哈希值的关联关系 map<hashcode, 摘要>
    * 2 每小时一个文件记录下被点击的摘要的hashcode
    * 3 将hashcode分片到多个文件
    * 4 遍历每个文件的hashcode，统计每个hashcode的次数，建立关联 map<hashcode, int>
    * 5 通过小顶堆每个文件取top10的hashcode
    * 6 使用小顶堆合并计算所有文件的top10
    * 7 如果展示全天，将每小时的top10合并后取top10
    * 8 将hashcode转换成摘要展示

* leetcode

  * 单调队列

    * [239.滑动窗口的最大值](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/239.滑动窗口的最大值.cpp)
    * 队列没有必要维护窗口中所有元素，只需要维护有可能成为窗口最大值的元素，保证队列中元素是单调递减的。
      * push() 如果新元素大于入口元素值，将入口元素弹出直到新元素值小于等于入门元素
    * pop() 如果弹出的值等于单调窗口中的出口元素，弹出
      * front() 返回出口元素
  
  * 小顶堆

    * [347.前K个高频元素](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/347.前K个高频元素.cpp)
    * [264.丑数2](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/264.丑数2.cpp)
  * [215. 数组中第K个最大元素](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/215.数组中第K个最大元素.cpp)
  
  * 大顶堆
    * [剑指40.最小的k个数](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/剑指40.最小的k个数.cpp)
  
  