* 哈系表是根据关键码的值来直接进行访问的数据结构，常用于快速判断一个元素是否出现在集合中，时间复杂度O(1)，用空间换时间。

* 哈希函数 hash function 将所有元素映射为哈系表上的索引
    * `index = hashfunction(key)`
    * `index = hashcode(key) % tablesize`
    * `0 <= index < tablesize`

* 哈希冲突：datasize > tablesize 不同元素映射为同一个索引
    * 链地址法(拉链法) : 在冲突的索引位置建立单链表
    * 线性探测法(tablesize > datasize) : 依靠哈系表中空闲的索引位置，在冲突的下一个索引位置放置冲突数据

* 三种常用的哈希结构
    * 数组
    * set 集合
        * 红黑树，平衡二叉搜索树，key有序，key不可修改，修改会导致整棵树错乱
        * `std::set`和`std::multiset`虽然底层用红黑树存储数据，但是使用哈希函数做映射
        * 优先使用`unordered_set`
        * key有序使用`set`
        * key重复有序使用`multiset`
        
        | 集合                 | 底层实现 | Key有无序 | 重复  | 更改数值 | 查询      | 增删      |
        |:------------------:|:----:|:------:|:---:|:----:|:-------:|:-------:|
        | `std::set`           | 红黑树  | 有      | 否   | 否    | O(logn) | O(logn) |
        | `std::multiset`      | 红黑树  | 有      | 是   | 否    | O(logn) | O(logn) |
        | `Std::unordered_set` | 哈系表  | 无      | 否   | 否    | O(1)    | O(1)    |
    
    * map 映射
            
        | 映射                 | 底层实现 | Key有无序 | 重复  | 更改数值 | 查询      | 增删      |
        |:------------------:|:----:|:------:|:---:|:----:|:-------:|:-------:|
        | `std::map`           | 红黑树  | 有      | 否   | 否    | O(logn) | O(logn) |
        | `std::multimap`      | 红黑树  | 有      | 是   | 否    | O(logn) | O(logn) |
        | `Std::unordered_map` | 哈系表  | 无      | 否   | 否    | O(1)    | O(1)    |
        
## 1 数组是最简单的哈希表
* 哈希值集中连续并且大小有限制时，使用数组

```cpp
// 242.有效的字母异位词
class Solution {
public:
    bool isAnagram1(string s, string t) {
        // 排序法
        // 时间复杂度O(nlogn)
        sort(s.begin(), s.end());  // 时间复杂度O(nlogn)
        sort(t.begin(), t.end());
        return s == t;
    }
    bool isAnagram2(string s, string t) {
        // 哈系表1
        // 空间 O(n)
        // 时间 O(n)
        if (s.size() != t.size()) return false;
        unordered_map<char, int> map;
        for (char c : s) map[c]++;
        for (char c : t) map[c]--;
        for (auto it : map) {
            if (it.second != 0) return false;
        }
        return true;
    }
    bool isAnagram3(string s, string t) {
        // 哈系表2
        // 空间 O(n)
        // 时间 O(n)
        if (s.size() != t.size()) return false;
        unordered_map<char, int> map;
        for (char c : s) map[c]++;
        for (char c : t) {
            if (--map[c] == -1) return false;
        }
        return true;
    }
    bool isAnagram(string s, string t) {
            // 数组
            // 空间 O(1)
            // 时间 O(n)
            vector<int> v(26, 0);
            for (char c : s) {  // a 97 A 65
                v[c - 'a']++;
            }
            for (char c : t) v[c - 'a']--;
            for (int i : v) {
                if (i != 0) return false;
            }
            return true;
        }
};
```

## 2 结果去重不排序 -> `unordered_map`

### 2.1 349.两个数组的并集

```cpp
class Solution {
public:
    // unordered_set
    // 空间 O(n)
    // 时间 O(n)
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> st1(nums1.begin(), nums1.end());
        unordered_set<int> st2;
        for (int n : nums2) {
            // if (st1.count(n) != 0) v.push_back(n);
            if (st1.find(n) != st1.end()) {
                st2.insert(n);  // 输出的每个元素一定是唯一的
            }
        }
        return vector<int>(st2.begin(), st2.end());
    }
};
```

### 2.2 202.快乐数
* 有无限循环发生 -> `unordered_map`

```cpp
class Solution {
public:
    // 快慢指针(有循环发生)
    // 空间复杂度 O(1)
    bool isHappy(int n) {
            int slow = n;
            int fast = n;
        do {
            slow = getSum(slow);
            fast = getSum(fast);
            fast = getSum(fast);
        } while (slow != fast);
        return fast == 1;
    }
    // unordered_set
    bool isHappy1(int n) {
        unordered_set<int> st;
        while (1) {
            int sum = getSum(n);
            if (sum == 1) return true;
            if (st.find(sum) != st.end()) return false;  // 最后都会无线循环
            st.insert(sum);
            n = sum;
        }
    }
    int getSum(int n) {
        int sum = 0;
        while (n) {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
};
```
