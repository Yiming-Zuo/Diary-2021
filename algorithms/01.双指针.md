[一文搞定常见的链表问题](https://blog.csdn.net/waveleting/article/details/108991903)

## 1 双指针 
* [344.反转字符串](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/344.反转字符串.cpp)
* [剑指05.替换空格](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/剑指05.替换空格.cpp)
* 排序数组双指针包夹求解，减少一次for循环
    * [15.三数之和](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/15.三数之和.cpp)
    * [18.四数之和](https://github.com/Yiming-Zuo/Diary-2021/blob/main/leetcode/15.四数之和.cpp)
### 1.1 #206 反转链表

```cpp
// 206 反转链表
// 双指针
class Solution {
public:
    ListNode* reverseList1(ListNode* head) {
        ListNode *pre = NULL;
        ListNode *cur = head;
        while (cur) {
            ListNode *tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
```

## 2 快慢指针

### 2.1 #27 移除元素
* 用一个快指针和一个慢指针在一个for循环中实现在两个for循环中的工作
* 时间复杂度 O(n2) -> O(n)
* 适用于数组和链表

```cpp
// #27 移除元素
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // 快慢指针法
        // 时间复杂度 O(n)
        int i = 0;
        for (int j = 0; j < nums.size(); j++) {
            if (nums[j] != val) nums[i++] = nums[j];
        }
        return i;
    }
};
```

### 2.2 剑指22.链表中倒数第k个结点

```cpp
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        // 快慢指针法
        ListNode *slow = head;
        ListNode *fast = head;
        while (k--) fast = fast->next;
        while (fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
```

### 2.3 #876.链表的中间结点

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        // 快慢指针
        ListNode *slow = head;
        ListNode *fast = head;
        while (fast) {
            if (fast->next == NULL) return slow;  // 奇
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;  // 偶
    }
};
```

### 2.4 #141.环形链表1

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;
        while (fast && fast->next) {  // 每一次循环两指针相差距离1，n此后两指针相遇。
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) return true;
        }
        return false;
    }
};
```

### 2.5 #142.环行链表2 

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *slow = head;
        ListNode *fast = head;
        while (true) {
            if (fast == NULL || fast->next == NULL) return NULL;
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow) break;
            // 两结点相遇时 f=2s f=s+nb
            // s=nb f=2nb
            // node=a+nb=a+s
            // s已经走了nb了，只要再走a就可以到达结点除
        }
        // f和s往前走a步后，fs相遇，此时就是结点处
        fast = head;
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 2.6 `202.快乐数`

## 3 滑动窗口

### 3.1 #209 长度最小的子数组
* 根据子序列和大小情况不断调整子序列的起始位置和结束位置
* O(n2) -> O(n)

```cpp
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        // 滑动窗口
        // 时间复杂度 O(n)
        int i = 0;
        int len = 0;
        int result = INT32_MAX;
        int sum = 0;
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            while (sum >= s) {  // 不断根据当前子序列的情况调整子序列的起始位置和结束位置
                len = j - i + 1;
                result = len < result ? len : result;
                sum -= nums[i++];
            }
        }
        return result = result != INT32_MAX ? result : 0;
        
    }
};
```